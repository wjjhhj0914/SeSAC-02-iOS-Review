# 03. App LifeCycle: 앱의 생명주기

앱이 실행되고 종료될 때까지 거치는 상태의 변화를 의미한다.<br />
앱은 메모리 관리와 배터리 효율을 위해 항상 다음 5가지 상태 중 하나에 머물게 된다.

## 1. 앱의 5단계 상태 변화

① **Not Running**: 앱이 시작되기 전이거나 완전히 종료되어 실행되지 않는 상태.<br />
② **Active**: **[Foreground]** 앱이 화면에 떠 있고, 사용자의 이벤트를 즉각적으로 처리할 수 있는 상태.<br />
③ **Inactive**: **[Foreground]** 앱이 화면에서 실행 중이지만, 아무런 이벤트도 받지 않는 상태. (전화가 오거나, 알림 창이 내려와 앱이 살짝 가려지는 짧은 순간)<br />
④ **Background**: 앱이 화면에 보이지 않지만, 뒤에서 여전히 코드를 실행하고 있는 상태. (음악 재생, 위치 추적 등)<br />
⑤ **Suspended**: 앱이 백그라운드에 있지만, 더 이상 코드를 실행하지 않는 상태. 메모리에만 올라가 있고, 메모리가 부족하면 시스템에 의해 강제 종료. (앱을 밀어서 종료해버리면 이 상태)<br />

## 2. 평화로웠던 iOS 12 이전의 시대 (AppDelegate의 독점)

iOS 13이 나오기 전까지, 아이폰 앱의 세상은 단순했다. 한 번에 하나의 앱만 화면에 보였기 때문이다. 이때는 **AppDelegate.swift**가 앱의 모든 것을 책임지는 만능 관리자였다.
* **프로세스 관리**: 앱이 켜지고 꺼지는 물리적인 생존 관리.
* **UI 관리**: 사용자의 눈에 보이는 화면 상태 관리.

## 3. iPadOS의 등장과 깨져버린 원칙

하지만 약 5년 전, **iPadOS**가 등장하면서 대격변이 일어난다. 아이패드에서는 화면을 분할하여 **하나의 앱 또는 여러 앱을 여러 개의 창**으로 띄울 수 있게 된 것이다.

> _앱은 하나인데, 화면은 두 개 이상일 수 있다?_

이 시점부터 "앱 하나당 Active 상태는 하나뿐이다"라는 공식이 깨졌다.<br />
그래서 애플은 기존의 거대한 책임을 두 개로 쪼개기로 한다.

### 책임의 분리 (Separation of Concerns)

* **AppDelegate(공장장)**: 앱이라는 프로그램 자체의 탄생과 죽음, 그리고 시스템적인 알림을 담당한다.
* **SceneDelegate(전시장 매니저)**: 사용자의 눈에 보이는 '화면(Scene)'이 켜져 있는지, 가려졌는지, 뒤로 숨었는지를 전담 마크한다.

## 4. 우리가 이 '생명주기'를 고도화해야 하는 이유

단순히 앱이 켜졌다는 것만 알아서는 수준 높은 앱을 만들 수 없다. 상황에 따른 세밀한 제어가 필요하기 때문이다.

### 사례 1: 금융 앱의 보안 (Privacy)

은행 앱을 쓰다가 카톡을 확인하려고 화면을 위로 올리는 순간, 앱은 **Inactive** 상태를 거쳐 **Background**로 간다. 이때 개발자는 생명주기를 낚아채서 "잠깐! 화면을 블러 처리해서 잔액을 가려줘!"라고 명령해야 한다.

### 사례 2: 유튜브의 비즈니스 모델 (Business Logic)

유튜브 프리미엄 사용자가 아니라면, 앱이 화면에서 사라지는(Background) 순간 영상 재생을 즉시 멈춰야 한다. 반대로 프리미엄 사용자라면, 계속 재생되게 두어야 한다. 이 판단 기준 역시 **앱의 생명주기 메서드** 안에 들어간다.

## 5. 왜 공부하는가?

결국 앱의 생명주기를 공부하는 이유는 사용자가 앱을 사용하는 매 순간을 개발자가 의도한 대로 완벽하게 통제하기 위해서다.
